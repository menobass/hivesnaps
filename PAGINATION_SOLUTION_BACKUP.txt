# Pagination Solution Design - Conversation Backup
# Date: August 10, 2025
# Branch: main (cleaned up from cursed feature/HIV-18-simple-pagination)

## PROBLEM IDENTIFIED:
- Feed pagination was causing infinite loops and glitchy behavior
- Cache bleeding between different feed types (following/newest/trending/my)
- Single snaps[] array shared across all feed types causing contamination
- Over-fetching (5 containers instead of 2)
- Memory abuse and performance issues

## USER'S COMPLETE SOLUTION DESIGN:

### 1. INITIAL LOAD STRATEGY:
- Load only 2 containers when feed screen first loads
- Populate feed with snaps from those 2 containers
- Default landing: "newest" feed (no "Load Newer" button initially)

### 2. FEED-SPECIFIC BEHAVIORS:

#### NEWEST FEED:
- Start with 2 containers
- Timer-based "Load Newer Snaps" button appears after 3-4 minutes
- "Load More Snaps" button when exhausted (accumulate more containers)

#### TRENDING FEED:
- Use only 2 latest containers (no additional loading)
- Rationale: Old posts aren't really "trending" anymore
- Simple and straightforward

#### FOLLOWING FEED:
- Start with 2 containers
- "Load More Snaps" when no more followed users' snaps available
- **MEMORY OPTIMIZATION**: Replace current feed with next 2 older containers
- Clear previous containers from memory (web-like pagination)
- "Load Newer Snaps" to go back to previous containers
- Bidirectional navigation (newer/older)

#### MY SNAPS FEED:
- Different approach: Pull directly from user's account comments/replies
- Look for comments made by user (e.g., "menoshop") to snap containers
- Use account-based API with proper pagination
- Allows access to ALL snaps including very old ones
- User needs to provide API reference for implementation

### 3. CACHE BLEEDING ISSUE:
- Current problem: Single state.snaps[] array shared across all feeds
- Cache exists per filter (snapsCache: Record<string, Snap[]>) but display state bleeds
- Solution needed: Per-filter state or clear-on-switch mechanism

### 4. TECHNICAL IMPLEMENTATION NOTES:
- Button-based loading (no automatic onEndReached)
- User control over when to load more content
- Memory efficient (especially for following feed)
- Web-like UX pattern
- No complex throttling or duplicate call prevention needed

## BROTHER'S CLAIM:
- Says pagination is "beyond user's paygrade"
- Taking over implementation
- Confidence level: HIGH (possibly overconfident üòè)

## RECOVERY PLAN IF NEEDED:
1. Create new branch from main
2. Implement per-filter state management first
3. Start with simple 2-container loading
4. Implement feed-specific pagination behaviors
5. Add timer-based "Load Newer" for newest feed
6. Implement memory-efficient replacement for following feed
7. Create reusable button components (LoadMoreButton, RefreshButton)
8. Test each feed type individually

## FILES THAT WERE MODIFIED (now reverted):
- app/FeedScreen.tsx
- hooks/useFeedData.ts  
- app/components/Snap.tsx
- components/LoadMoreButton.tsx (created then deleted)
- components/RefreshButton.tsx (created then deleted)
- components/feed/index.ts (created then deleted)
- types/components.ts (created then deleted)

## KEY INSIGHTS:
- Web-like pagination is more predictable than infinite scroll
- Memory optimization crucial for mobile performance
- Each feed type has different content patterns and needs
- User control > automatic behavior for pagination
- Cache isolation prevents cross-feed contamination

---
# Status: ON HOLD - Brother taking over
# Backup created in case confidence meets reality üçø
